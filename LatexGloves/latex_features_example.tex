\documentclass[12pt, a4paper]{article}
\input{../LatexGloves/latex_math_header.tex}

\begin{document}
    \section{…}

    $\sin x$\\
    $\sin(x+y)$\\
    $\supp x$\\
    $\supp(x+y)$

    \begin{gather}
        \sN \\
        \sR \\
        \sC \\
        \sZ
    \end{gather}

    \begin{equation}
        \label{eq:upsilon}
    \end{equation}

    \begin{gather}
        \Upsilon \\
        \RNumb{2875} \\
        \rm 121
    \end{gather}



    \begin{equation}
        \begin{cases}
            1+1=\correction{3}{2} \\
            1+1=\correction{2}{3} \\
            \sphericalangle 
        \end{cases}            
    \end{equation}

    \green{Зелёный текст!}\\
    \correction{Неправильно}{Правильно}

    \textbb{fsdgfglkdfglkkhkuhkjkh}


    \begin{equation}    
        \vec{vector} = \vec{vec1} + \vec{addition\_vector}
    \end{equation}    

    \texttt{Hello! Привет!! >= 1}

    \begin{equation}
        \symbf{bold_a = \sqrt{\frac{10}{\vec{34345}}}} + \sqrt{\frac{10}{\vec{34345}}}
    \end{equation}


    \begin{gather}
        \cancel{Bad thing}\\
        \bcancel{Bad thing}\\
        \xcancel{Bad thing}\\    
        \cancelto{\infty}{\frac{e^n}{n}}\\
        \Re z \\
        \Im z \\
        \supp s
    \end{gather}

    \begin{equation}
        \begin{bmatrix}
            a_{11} &  & a_{1n} \\
            a_{21} & & \\
            & & \\
            a_{n1} & & a_{nn}
        \end{bmatrix}
    \end{equation}
    
    \begin{equation}
        \begin{bmatrix}
            a_{11} & \cdots & a_{1n} \\
            \vdots & \ddots  & \vdots \\
            a_{n1} & \cdots & a_{nn}
        \end{bmatrix}
    \end{equation}

    \textbf{\textit{Hello!}}

    % \begin{minted}{../LatexGloves/PseudoLexer.py:PseudoLexer -x}
    %     import numpy as np
            
    %     def incmatrix(genl1,genl2):
    %         m = len(genl1)
    %         n = len(genl2)
    %         M = None #to become the incidence matrix
    %         VT = np.zeros((n*m,1), int)  #dummy variable
            
    %         #compute the bitwise xor matrix
    %         M1 = bitxormatrix(genl1)
    %         M2 = np.triu(bitxormatrix(genl2),1) 
        
    %         for i in range(m-1):
    %             for j in range(i+1, m):
    %                 [r,c] = np.where(M2 == M1[i,j])
    %                 for k in range(len(r)):
    %                     VT[(i)*n + r[k]] = 1;
    %                     VT[(i)*n + c[k]] = 1;
    %                     VT[(j)*n + r[k]] = 1;
    %                     VT[(j)*n + c[k]] = 1;
                        
    %                     if M is None:
    %                         M = np.copy(VT)
    %                     else:
    %                         M = np.concatenate((M, VT), 1)
                        
    %                     VT = np.zeros((n*m,1), int)
            
    %         return M
    %     \end{minted}


    
\end{document}