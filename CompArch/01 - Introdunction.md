# Архитектура ЭВМ

Порядок проведения курса ($\copyright$ Радмила Чинаева)

>Основной препод: ***Павел Сергеевич Скаков***
>70 баллов за домашки.
>Максимальная потенциальная сумма баллов за домашки 80, но ставится max(баллы, 70)
>30 баллов за устный зачет в конце.
>Зачет «в духе экзамена» (?...).
>Зачет дифференцированный (вероятно, имеется ввиду, что есть оценки), поэтому для нас от экзамена отличаться не будет ничем (?).
>Будем писать тесты. 3 теста по первым трем лекциям. (Исправьте числа если я не так услышала.)
>Нужно отправлять отчет по дз, устной сдачи нет, но если есть проблемы, можно поговорить.
>Дедлайны жесткие, даже с опозданием на 6 секунд не примут.
>Вопросы по дз писать Яковлевой. Но она просит погуглить, прежде чем задавать ей вопросы. Отвечать обещает в течение суток. Если писать вечером в день дедлайна, можно и не дождаться ответа.
>После проверки будет табличка с со столбиками-критериями оценивания.
>Пересдавать дз нельзя. 
>Допуск к зачету - 40 баллов.
>В среднем люди набирают на зачете 12-15 баллов.
>На зачете может быть то, чего не было на лекции, но было в домашке. На лекции рассказываются все общие идеи, читать дополнительно по идее не надо.
>Литература: Таненбаум. 
>В курсе более свежая информация, чем в книге.
>Для подробной и актуальной информации читать стандарты.
>Рекомендуется гуглить и читать на английском. Информации гораздо больше.
>Не рекомендуется читать русскую википедию. Ее переводят криво. Английскую читать можно. Снизу можно найти ссылки на более подробные статьи. Только википедии для подготовки к зачету не хватит.
>Нужно говорить, что начался перерыв, иначе его не будет.

## Зачем нужен предмет





Чтобы отличать бракованные процессоры от нормальных:

![image-20210911115842836](images/intel_core_meme.png)

## Представление чисел

### 1. Целые числа

#### Заострений не будет: *БЕЗ*знаковые целые числа

Каждому битику сопоставляем вес его разряда.

Байт - ***минимальная адресуемая ячейка памяти***, минимальная, имеющая свой адрес. На ***данный*** момент техника стала менее разнообразная, более стандартизированная, поэтому везде 8 бит, но раньше бывало и 6.

Происходит завязывание программного обеспечения и железа. Сейчас никому не будет нужна железка, где байт -- не 8 бит.

Какой порядок битиков в байтике? Никакой. Это никак нельзя узнать, так как они не адресуемые.

#### Интереснее: кодирование чисел со знаком

1. Отдать один из битиков: отдать под знак. Обычно отдают самый старший. Теперь это признак знака (+-). Байт: [-127, 127]
   Так положительные и даже один из нулей будут совпадать с беззнаковым представлением.
2. Сначала кодируем вроде бы простое беззнаковое число, потом вычитаем $\approx$ половину диапазона. Но тогда ноль ... не нольный получится
3. "Двоичный дополнительный код" = "Дополнение до двух" -- старший бит имеет вес $-2^n$. Это доминирующее представление чисел со знаком. Unless overwise specified, используется именно это представление. Эта форма хороша, так как нет двух нулей, да ещё и правила сложения работают, как и ожидается. Чтобы инвертировать, нужно инвертировать все битики 
4. Дополнение до одного: Высший бит тоже имеет отрцательный вес

>  Модулярная арифметикa -- число интерпретируется как значение из некоторого диапазона

В пункте 3 происходит то же самое, только со сдвинутым диапазоном.

Если присвоить значение переменной ```int``` $\longrightarrow$ ```unsigned int```, то при положительном битики не изменятся, а чтобы получить, например, самое большое положительное значение - это перевод -1 в unsigned-тип.

Удобно, когда можно временно выходить за границы диапазона, если знаешь что делать: например, 250 + 10 - 20 -- даже в unsigned byte типе получится то, что планировали: 240.

По стандарту **C++20**, int должен быть в дополнении до 2х (как минимум 16 бит. На линуксе - ровно так) (сделали исследование, только одна компания делает не так, причём только на эмуляции), но стандарт С писался тогда, когда были разные представления, поэтому стандарт очень много чего допускал (а именно, что главное - чтобы можно было как-либо хранить хотя бы числа, характерные для 16 бит).

> Интересный вариант: кодировать числа в порядке $0 \longrightarrow -1 \longrightarrow 1 \longrightarrow -2 \longrightarrow \ldots$. 
>
> Это хоршо тем, что можно непосредственно записать битики малоразрядного числа в многоразрядное, и получится то же значение.
>
> Казалось бы, хранить это сложно. Ноо. Какие последовательности бит соответствуют отрицательным числам?  $1, 3, 5, \ldots \Longleftrightarrow \mathbf{000}1, \mathbf{001}1, \mathbf{010}1, \mathbf{011}1, \ldots$   
>
> Нетрудно заметить, что теперь младший бит отвечает за знак, а остальные - за модуль.

Рассмотрим систему, в которой основание равно $-2$. 

Биты: $1, -2,~ 4, -8,~ 16, -32 \ldots$

$value \in [] $

Если чётное число, то отрицательных значений вдвое больше, чем положительных. Иначе -- наоборот.

___

На заре компьютеростроения система счисления была 10.

Первые компьютеры и арифмометры использовали десятичную систему. Ее минусы:

- Сложнее организовать арифметические операции, чем в двоичной

- Запись одних и тех же чисел требует большего количество информации
- Следовательно нужно больше железа

Математики посчитали, что самое эффективное основание - e (число Эйлера). Ближайшее к нему - троичная. Но двоичную проще использовать. И много алгоритмов и готовых программ.

С некоторой вероятностью, когда-нибудь человечество перейдёт на неё, но пока что мы в потенциальной яме.



## Дробные числа

Как переводить дробную часть? Просто идти в порядке уменьшения дроби $\left( \frac{1}{2}, \frac{1}{4}, \ldots \right)$

Как перевести, например, 1/10?
$$
0.1_{10} = \frac{1}{16} + \frac{1}{32} + \ldots
$$
Для перевода десятичной дроби 0.1 в двоичную систему, необходимо  выполнить последовательное умножение дроби на 2, до тех пор, пока  дробная часть не станет равной 0 или пока не будет достигнута заданная  точность вычисления. Получаем:
$$
0.1 ∙ 2 = 0.2 (0) \\ 
0.2 \cdot 2 = 0.4 (0) \\
0.4 \times 2 = 0.8 (0) \\
0.8 ∙ 2 = 1.6 (1) \\
0.6 ∙ 2 = 1.2 (1) \\
0.2 ∙ 2 = 0.4 (0) \\
0.4 ∙ 2 = 0.8 (0) \\
0.8 ∙ 2 = 1.6 (1) \\
0.6 ∙ 2 = 1.2 (1) \\
0.2 ∙ 2 = 0.4 (0) \\
0.4 ∙ 2 = 0.8 (0) \\
$$
Ответом станет прямая последовательность целых частей произведения. Т.е. 

$0.1_{10} = 0.00011001100_2 = 0.0(0011)_2$

Однако есть несколько способов записать это битиками.

1. Фиксированная точка: заранее сказать, сколько бит будет под целую часть, а сколько -- под дробную. Для 16 бит:
   $$
   \mathbb{ value \in \left[0, 255\frac{255}{256} \right] \cap \left\{ \frac{n}{256} \bigg| \quad n \in  N \, \right\} }
   $$
   Хорошо - что можно складывать с целыми числами через reinterpret_cast.

   При компиляции при вводе литералов нужно округлять к ближайшему числу из доступных - самый точный способ.

   
   Есть несколько примеров чисел. Как произвести умножение? 

2. 