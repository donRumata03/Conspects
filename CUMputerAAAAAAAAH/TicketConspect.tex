\documentclass[12pt, a4paper]{article}
\input{../LatexGloves/latex_math_header.tex}

\renewcommand{\labelenumii}{\theenumii}
\renewcommand{\theenumii}{\theenumi.\arabic{enumii}.}

\graphicspath{{images/}}


\title{Конспект к экзамену по билетам (архаичные ЭВМ) \\ 1-й семестр} 

\author{
  \vova
  \and
  Скаков Павел Сергеевич (лектор)\\
  \texttt{t.me/pavelxs}
}

\date{\today}



\begin{document}

\maketitle
\newpage
\tableofcontents
\newpage


\section{Введение}

Максимально сжатый материал: если читатель не знаком с курсом, возможно, 
стоит сначала изучить конспект Тимофея на Overleaf.


\section{Названия билетов (ровно как в оригинале)}

\begin{enumerate}
    \item Устройство памяти
    \begin{enumerate}
        \item Элементная база вычислительной системы: логические элементы, триггеры.
        \item Оперативная память: статическая/динамическая, организация.
        \item Оперативная память: характеристики, типы динамической памяти. NUMA.
        \item Кэш-память.
        \item Протоколы когерентности кэш-памяти.
        \item Носители информации: магнитные, оптические и на основе флеш-памяти. RAID.
    \end{enumerate}
    
    
    \item Архитектура процессорных систем
    \begin{enumerate}
        \item Архитектура фон Неймана и её альтернативы.
        \item Архитектура набора команд (ISA) и микроархитектура.
        \item Конвейерная архитектура. Конвейер MIPS.
        \item Проблемы конвейера (hazards) и пути их решения.
        \item Суперскалярная и VLIW архитектуры. Спекулятивное исполнение. Уязвимости классов Spectre и Meltdown.
        \item Многоядерные/многопроцессорные системы, одновременная многопоточность (SMT/HT).
    \end{enumerate}
\end{enumerate}

Нужно ответить на два вопроса: по одному из каждой части. Пользоваться ничем нельзя, отвечать сразу.


\section{О чём говорить при каждом из билетов?}


\subsection{Элементная база вычислительной системы: логические элементы, триггеры.}

Европейские и американские обозначения логических элементов

Полусумматоры и сумматоры (медиана + $XOR$ или два полусумматора + $OR$)

RS-триггер, каноническая и енаиболее эффективная версия — через два ИЛИ-НЕ.

Проблемы высоких частот и малого размера, «В Ethernet соотношение сигнал/шум — как разговаривать рядом с турбиной самолёта»

$\Longrightarrow$ Синхронная версия RS-триггера, D-триггер через «не» на входе.



\subsubsection{MEM}

Декодер 3to8 (для каждого из 8 выходов $AND$ от трёх, возможно, инвертированных входов) 
$\Longrightarrow$ мультиплексор ($3 + 8 → 1$) и демультиплексор ($3 + 1 → 8$).

Из этого можно сделать модуль памяти «Mem» на 8 бит: 

Входы: 3 адресных бита, $R/W$, $C$ (clock), $D$ (запись, если выбран режим $W$).

Выход: «Q» — если выбран режим $R$ (не обязательно только в этому случае)
— на нём значение, соответствующее биту по адресу $\overline{A_0 \! A_1 \! A_2}$.


\subsubsection{JK-триггер}

JK-триггер (Входы $J, K$, синхронный, $\Lleftarrow$ умеет инвертировать состояние при двух единицах). 
Крафтится из двух RS-триггеров с тактированием в противофазе, 
на вход первого кроме оригинальных входов $J, K$ через «AND» даётся то, 
что запомнил второй (то есть что было на первом до начала такта).
В нормальной версии результат ($Q$ и $\tilde Q$) берётся из выходов первого триггера.

\subsubsection{Физические основы работы логических элементов}

Нас интересуют в основном транзисторы.
По многим причинам победила $CMOS$-логика, конструирующая только транзисторы (причём полевые)
для конструкции элементов. Это позволяет минимизировать потребляемую энергию, так как ток течёт только при переключении.
В отличие от полевых транзисторов (где он нужен через базу для поддержания открытого состояния),
а также $NMOS$ логики, где он течёт по резистору в некоторых случаях (когда транзистор открыт).

В случае $CMOS$ логики расход энергии растёт при увеличении частоты почти линейно по понятным причинам.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{images/general_cmos_element_scheme.png}
    \caption{Общий принцип построения схем в CMOS логике}
    \label{fig:cmos_general}
\end{figure}
\FloatBarrier

В качестве элементарных частиц используем $NOT, NAND, NOR$ (нельзя сделать $AND$ и $OR$ эффективнее, чем соответствующий $NAND/NOR \circ NOT$)

Fun Fact: можно сделать $NOR$ и $NAND$ на много входов эффективнее, чем просто внешне композировать (например, для трёх — 6 вместо 8-и).


\subsubsection{Дребезг контактов}

Кнопки из реальной жизни при нажатии не сразу устанавливается в новой состояние, а сначала колеблется. 
Это назвается Contact bounce (дребезг контактов). Причём чем старше и некачественнее контакты, тем дольше будет происходить bouncing.

Есть несколько подходов к борьбе с ним. Бывает, программно, бывает аппаратно.
Причём криме вопросов реализации возникают ещё и концептуальные. 
Проще всего реагировать на нажатие с запозданием: по истечении времени с начала или с последнего изменения.
Другой вариант — реагировать как только произошло изменение после затишья, но после этого игнорировать дребезг, пока не установится.
Однако, если у нас не просто бинарная кнопка с одним контактом «нажат/не нажат», 
а имеющая положения «не нажата, положение 1 и положение 2» и мы хотим на выход подавать бинарный сигнал в виде последнего «ка\'санного» контакта, 
то всё гораздо очевиднее и у нас есть ультимативное решение через триггер и, возможно, транзистор.
Не забыть про подтягивающие резисторы.




\subsection{Оперативная память: статическая/динамическая, организация.}

Папмять располагают в 2D решётчатой структуре.

Количество проводов $\propto cols + rows  \Rightarrow O(\sqrt{memory\_size})$

$Row$ отвечает за выбор ряда. Если он ноль, ячейка вообще не работает.

Если подаётся $true$, ячейка открывается. Можно считывать информацию с соответствующих $Col$ и $\overline{Col}$.
Также можно записывать на эти входы.


Статическая память строится как 

\begin{center}
    \begin{tabular}{|| m{10em} | m{10em} | m{12em} ||} 
     \hline
     &                          \textbf{Статическая память}  & \textbf{Динамическая память} \\ [0.5ex] 
     \hline\hline
     Скорость &                 быстрая             & медленная \\ 
     \hline 
     Количество транзисторов &  Много (≈6)          & Мало (обычно один + кондерсатор) \\ 
     \hline
     Надёжность &  Наличествует          & Постоянно дегенерирует $\Rightarrow$ надо регенерировать  \\
     \hline
     Примеры &  Регистры, кэш          & Оперативная память, видеопамять  \\
     \hline
    \end{tabular}
\end{center}

Параметры, по которым оценивается память:
\begin{center}
    Объём, 
    
    скорость доступа («latency»), 
    
    скорость передачи («throughput», пропускная способность)
\end{center}

Уязвимость Raw-Hammer: если очень долго обращаться к ячейкам, соседним с данной, можно установить её в ноль.




\subsection{Оперативная память: характеристики, типы динамической памяти. NUMA.}

Порядок работы с памятью: 
\begin{enumerate}
    \item Процессор сообщает о таймингах
    \item Всё время идет синхронизация 
    \item Выбор строки $\Rightarrow$ модуль динамической памяти заносит строку в статическую
    \item 
\end{enumerate}




\end{document}