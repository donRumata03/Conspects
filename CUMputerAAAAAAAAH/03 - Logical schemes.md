# Логические операции и схемы

Популярные операции в порядке уменьшения приоритета:

| Название | Математическое | Побитовое | Логическое |
| -------- | -------------- | --------- | ---------- |
| НЕ       | $\lnot$        | ~         | !          |
| И        | $\land$        | &         | &&         |
| XOR      | $\oplus$       | ^         | !=         |
| ИЛИ      | $\lor$         | \|        | \|\|       |



Для рисования логических схем есть два стандарта: Уродский и нормальный.

1. ### Уродский (он же - американский)



2. ### Нормальный (европейский и советский)



## Работа со схемами

Если линии просто пересекаются, то они не связаны - узлы обозначаются точками.

Создание логических схем идейно очень похоже на программирование.

### Полусумматор (HSUM)

Составим таблицу истинности (понятно, какая..)

### Сумматор (SUM)

У сумматора три входа: он ещё учитывает перенос из предыдущего разряда.

### RS-триггер

Его входы: R; S

| S    | R    | Q         |
| ---- | ---- | --------- |
| 0    | 0    | СОХРАНЯЕТ |
| 0    | 1    | 0         |
| 1    | 0    | 1         |
| 1    | 1    | НЕ ВАЖНО  |

Схема - классическая.



### Мультиплексор (MUX)

***ТЗ***: Есть две группы входов: первая обозначает двоичным числом, какой вход из второй группы передавать на единственный выход.

***Решение***: Построим **ДЕ**шифратор, он будет выдавать $2^n$ проводов (для каждого входа второй группы по одному), причём единицей будет только тот элемент, который соответствует закодированному числу.

Каждый вход $and$-им с соответствующим проводом, а потом полученные результаты или-м схемой логарифмической глубины, получая требуемый 1 провод.

### Демультиплексор (DEMUX)

***ТЗ***: Есть две группы входов: первая обозначает двоичным числом, на какой из выходов передавать единственный вход второй группы.

***Решение***: также построим дешифратор, только теперь размножаем входной контакт второй группы для каждого их $2^n$ выходов и $and$-им его с выходами мультиплексера. Конец. 

___

***Домашнее задание***: составить схемы этих элементов (мультиплексор и демультиплексор)

Проще всего — посмотреть [сюда](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A8%D0%B8%D1%84%D1%80%D0%B0%D1%82%D0%BE%D1%80_%D0%B8_%D0%B4%D0%B5%D1%88%D0%B8%D1%84%D1%80%D0%B0%D1%82%D0%BE%D1%80) и [сюда](https://neerc.ifmo.ru/wiki/index.php?title=%D0%9C%D1%83%D0%BB%D1%8C%D1%82%D0%B8%D0%BF%D0%BB%D0%B5%D0%BA%D1%81%D0%BE%D1%80_%D0%B8_%D0%B4%D0%B5%D0%BC%D1%83%D0%BB%D1%8C%D1%82%D0%B8%D0%BF%D0%BB%D0%B5%D0%BA%D1%81%D0%BE%D1%80).

___

## Синхронизация



Насколько велика проблема синхронизации? Даже теоретически за такт процессора $3GHz$ нельзя передать информацию на расстояние более 10 сантиметров. Поэтому рост тактовой частоты примерно остановился.

Более того, энергия через магнитное поле особенно хорошо передаётся при высокой частоте. Происходят искажения.

Если много проводов, и все они работают на высокой частоте, они друг на друга ужасно сильно влияют.

А ещё происходит дополнительная задержка за счёт индуктивности.

Используются запутанные технологии, чтобы таки передать информацию. Например, Ethernet, можно про него почитать. Нужно применять сложные схемы кодирования, ведь соотношение сигнал/шум такое, как будто стоишь рядом с реактивным самолётом. Если провод нормальный, то информации для восстановления достаточно, чтобы потери были минимальны.

> Интересный факт: кабели Ethrenet высокой категории с экранированием 

Отсюда надежда на передачу информации по оптоволокну, так как фотоны, когда летят рядом, друг на друга $\approx$ не влияют.

Но на электроны проще влиять - магнитным полем,  а на фотоны - не совсем понятно.



Поэтому ввели ещё один провод - ***синхронизации***. Если на нём ноль, это значит, что информация на остальных невалидна (находится в переходном состоянии, и на неё не надо реагировать). Это нужно для борьбы с эффектами неодновременности прихода сигналов на разных проводах, без этого могло бы быть невалидное состояние. 

Например, есть и синхронные варианты RS-триггера ($and$-им со входом синхронизации все входы).

Бывает синхронизации по уровню и по фронту. (По фронту элемент воспринимает информацию только в тот момент, когда происходит переход из одного состояния в другое). Чтобы сделать синхронизацию по фронту, нужно опускаться "ниже", чем логические элементы.

Если увеличивать тактовую частоту, то схема будет работать всё быстрее и быстрее, пока вообще не перестанет работать (это произойдёт, когда период импульсов станет меньше времени срабатывания).

____

Существует $D-trigger$: он синхронный, делается путём постановки элемента НЕ от входа к R и S.

___

Элемент памяти на 8 бит: один выход, 6 входов.

3 входа - адрес, один - значение, ещё один - R/W и последний - вход синхронизации.

Делается это через мультиплексер и демультиплексер 3-to-8 и т.д.



***Домашнее задание*** (задание на оценку) по построению логических схем. Построить JK-триггер.

То же самое, что и RS-триггер, но при состоянии входов 1 | 1 будет инвертироваться значение (за один такт происходит ровно одно инвертирование)

***Решение домашнего задания***: Добавлением and-ов запрещаем переключение в противоположное состояние. Но этого недостаточно. Нужно за всё время держания 1, 1, 1 на входах инверсия проихошла только один раз. Для этого полезно помнить предыдущее состояние (до инверсии), для этого используем ещё один RS-триггер с противоположной синхронизацией. В и тоге получается такая схема.

<img src="https://digteh.ru/digital/JKtrigg/01.gif" alt="Структурная схема jk триггера" style="zoom:200%;" />

Но она срабатывает на полтакта позже.

Что будет, если перенести инвертор к синхронизации левого триггера? Он будет немного бажный, хотя и сработает сразу.



А как сделать, чтобы схема переключалась сразу, а не через полтакта? Вернём инвертор назад, но возьмём выходы схемы из выходов первого RS-триггера. 

_____

## Внутреннее устройство логических элементов

Раньше логик (`логика` - способ построения логических элементов) было много, но теперь для высокоскоростных остались только $CMOS$ и никаких изменений в этом не предвидится.

В качестве переключателей используются транзисторы.


Раньше было ещё и реле, но оно слишком медленное и огромного размера, а ещё ужасно дико щёлкает (громче сверчков).

А ещё - высокая вероятноть поломки. Если умножить количество на вероятность поломки, то получится, что по домику наод постоянно лазать и пытаться понять, какая из них сломалась. 

Потом стали использовать лампочки, а потом - и транзисторы. Затем - на одном кристале стали делать несколько транзисторов $\to$ большие интегральные схемы $\to$ **СВЕРХ**большие интегральные схемы, потом перестали измерять поколения.



Транзисторы бывают биполярные и полевые.

Сейчас полевые переключаются быстрее, а раньше было не так. Плюс ещё биполярные транзисторы управляются током, и поэтому тратят огромное и немасштабируемое количество энергии.

NMOS - логика на NPN транзисторах.

Как сделать инвертор? У нас есть диод (1 pn переход), можно его использовать.