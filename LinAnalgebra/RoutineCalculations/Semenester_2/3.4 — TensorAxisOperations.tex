\documentclass[12pt, a4paper]{article}
\input{../../../LatexGloves/latex_math_header.tex}

% \usepackage{geometry}
% \geometry{
%     a4paper,
%     left=30mm,
%     right=30mm,
%     top=30mm,
%     bottom=20mm
% }

\newcommand\arr[2]{\left(\begin{array}{#1}#2\end{array}\right)}


\author{Латыпов Владимир Витальевич, \\ ИТМО КТ M3138, \Huge{\textit{\textbf{вариант 10}}}}
\title{Типовик по линейной алгебре №3, задание 4 «Алгебраические операции с тензорами.»}

\begin{document}
    \tit

    \section{Формулировка условия}

    \begin{statement}
        Условие таково:

        Тензор $\alpha^{ijk}$ (3 раза контравариантный) 
        задан трехмерной матрицей третьего порядка $A = \lVert \alpha^{ijk} \rVert$.

        \begin{itemize}
            \item Вычислить матрицу транспонированного тензора $\beta^{ijk} = \alpha^{kji}$.
            \item Вычислить матрицу полностью симметричного тензора $\alpha^{(ijk)}$.
            \item Вычислить матрицу полностью антисимметричного тензора $\alpha^{[ijk]}$.
            \item Вычислить матрицу тензора $\alpha^{(i|j|k)}$, симметризованного по индексам $i$ и $k$.
            \item Вычислить матрицу тензора $\alpha^{i[jk]}$, антисимметризованного по индексам $j$ и $k$.
        \end{itemize}

        \begin{equation}
            A = \arr{ccc|ccc|ccc}{
                -2 & 3 & 4 & 3 & 6 & 0 & 2 & 1 & 3 \\
                3 & -1 & -4 & 2 & 4 & -6 & 1 & 0 & 2 \\
                -1 & 2 & 2 & 1 & -2 & 3 & 1 & 0 & 4 \\
            }
        \end{equation}

    \end{statement}

    \section{Транспонируем}

    Заметим, что для применения перестановки достаточно совершить одну транспозицию, 
    поменяв первую координату с третьей (для матрицы это строчка и слой соответственно), то есть фиксируя вторую (столбец).

    Тогда выпишем двухмерные матрицы, имеющие константный столбец и, транпонировав их, вернём на место.

    Для надёжности будем испольовать \url{matrixcalc.org}.

    \begin{equation}
        \alpha^{?1?} = \left(\begin{matrix}
            -2 & 3 & 2 \\
            3 & 2 & 1 \\
            -1 & 1 & 1
        \end{matrix}\right) \rightarrow \left(\begin{matrix}
            -2 & 3 & -1 \\
            3 & 2 & 1 \\
            2 & 1 & 1
        \end{matrix}\right)
    \end{equation}

    \begin{equation}
        \alpha^{?2?} = \left(\begin{matrix}
            3 & 6 & 1 \\
            -1 & 4 & 0 \\
            2 & -2 & 0
        \end{matrix}\right) \rightarrow \left(\begin{matrix}
            3 & -1 & 2 \\
            6 & 4 & -2 \\
            1 & 0 & 0
        \end{matrix}\right)
    \end{equation}


    \begin{equation}
        \alpha^{?3?} = \left(\begin{matrix}
            4 & 0 & 3 \\
            -4 & -6 & 2 \\
            2 & 3 & 4
        \end{matrix}\right) \rightarrow \left(\begin{matrix}
            4 & -4 & 2 \\
            0 & -6 & 3 \\
            3 & 2 & 4
        \end{matrix}\right)
    \end{equation}


    И, собственно, записываем полученную новую гадость назад, причём в том же порядке, в котором вынимали старую…

    \begin{equation}
        B = \arr{ccc|ccc|ccc}{
            -2 & 3 & 4     & 3 & -1 & -4      & -1 & 2 & 2 \\
            3 & 6 & 0    & 2  & 4 & -6     & 1 & -2 & 3 \\
            2 & 1 & 3     &  1 & 0 & 2     & 1 & 0 & 4 \\
        }
    \end{equation}
    

    \section{Симметрирование}

    Здесь посчитаем по определению, однако ручками звучит очень больно. Поэтому:

    \begin{lstlisting}[language=Python]
        def full_symmetrize_tensor(t):
        	n = len(t.shape)
	        return Fraction(1, math.factorial(n)) * sum([
                (t + Fraction()).transpose(p) 
                for p in permutations(range(n))
                ])
    \end{lstlisting}

    Получаем вывод:

    \begin{lstlisting}[language=Python]
        Symmetrized:
        [
            [
                [Fraction(-2, 1) Fraction(3, 1) Fraction(5, 3)]
                [Fraction(3, 1) Fraction(7, 3) Fraction(1, 6)]
                [Fraction(5, 3) Fraction(1, 6) Fraction(2, 1)]
            ]
            [
                [Fraction(3, 1) Fraction(7, 3) Fraction(1, 6)]
                [Fraction(7, 3) Fraction(4, 1) Fraction(-8, 3)]
                [Fraction(1, 6) Fraction(-8, 3) Fraction(5, 3)]
                ]
            [
                [Fraction(5, 3) Fraction(1, 6) Fraction(2, 1)]
                [Fraction(1, 6) Fraction(-8, 3) Fraction(5, 3)]
                [Fraction(2, 1) Fraction(5, 3) Fraction(4, 1)]
            ]
        ]
    \end{lstlisting}

    Зто записывается в виде многомерной матрицы
    \begin{equation}
        \arr{ccc|ccc|ccc}{
            -2 & 3 & \frac{5}{3}           & 3 & \frac73 & \frac16              & \frac53 & \frac16 & 2 \\
            3 & \frac{7}{3} & \frac{1}{6}  & \frac73  & 4 & -\frac83            & \frac16 & -\frac83 & \frac53 \\
            \frac{5}{3} & \frac{1}{6} & 2  &  \frac16 & -\frac83 & \frac53      & 2 & \frac53 & 4 \\
        }
    \end{equation}


    \section{Альтенирование}

    По факту — тут достаточно найти значение для одного элемента, индексы которого — перестановка, 
    а потом поставить нули везде, где не она и полученное значение со знаком $(-1)^{\varepsilon(\sigma_1) + \varepsilon(\sigma_2)}$
    , где вторая — чётной очередной перестановки, а первая — исходной.

    Но проще использовать автоматизированну. протестированную версию…


    Стало лениво перепечатывать в $LaTeX$, поэтому автоматизируем это:

    \begin{lstlisting}[language=Python]
        def fraction_as_latex(f):
            if f.denominator == 1:
                return str(f.numerator)
            else:
                return f"\\frac{{{f.numerator}}}{{{f.denominator}}}"
    
        def format_3d_matrix(m): # M's internal (right index sequence)
            s = m.shape
            for i in range(s[0]):
                line = []
                for k in range(s[2]):
                    for j in range(s[1]):
                        line.append(fraction_as_latex(m[i][j][k]))
                print(f"{' & '.join(line)}\\\\")
    \end{lstlisting}



    Аналогично симметрированию, но умножаем на -1, если нечётная перестановка.

    \begin{lstlisting}[language=Python]
        def full_alternate_tensor(t):
            n = len(t.shape)
	        return 
            Fraction(1, math.factorial(n)) * 
                sum([
                    Fraction(perm_parity(list(p))) * 
                    (t + Fraction()).transpose(p) 
                    for p in permutations(range(n))
                    ])
    \end{lstlisting}

    Получаем:

    \begin{equation}
        \arr{ccc|ccc|ccc}{
            0 & 0 & 0 & 0 & 0 & \frac{5}{6} & 0 & \frac{-5}{6} & 0\\
            0 & 0 & \frac{-5}{6} & 0 & 0 & 0 & \frac{5}{6} & 0 & 0\\
            0 & \frac{5}{6} & 0 & \frac{-5}{6} & 0 & 0 & 0 & 0 & 0\\
        }
    \end{equation}




    \section{Симметрирование по части индексов}

    Для части индексов пришлось немного повозиться, но суть та же:

    
    \begin{lstlisting}[language=Python]
        def slice_around(indexes, n):
            # Create slices around indexes
            slice_between = [-1] + indexes + [n]
            slices = []
            for i in range(len(slice_between) - 1):
                slices.append(list(range(slice_between[i] + 1, slice_between[i + 1])))
            return slices
        
        # print(slice_around([0, 3, 4], 6))
        
        def interchange_arrays(first, second):
            res = [first[0]]
            for i in range(0, len(second)):
                res.append(second[i])
                res.append(first[i + 1])
            return res
        
        def flatten(lst):
            return [item for sublist in lst for item in sublist]
        
        def permute_index_set(n, permuting_index_set):
            slices = slice_around(permuting_index_set, n)
        
            raw_ps = permutations(permuting_index_set)
            for p in raw_ps:
                yield flatten(interchange_arrays(slices, [[v] for v in p]))
    \end{lstlisting}

    Теперь просто в качестве перестановок передаём вызов permute\_index\_set от нужных аргументов.

    Получаем ответ на нашем тензоре:

    \begin{equation}
        \arr{ccc|ccc|ccc}{
            -2 & 3 & 4 & 3 & \frac{5}{2} & -2 & \frac{1}{2} & \frac{3}{2} & \frac{5}{2}\\
            3 & \frac{5}{2} & -2 & 2 & 4 & -6 & 1 & -1 & \frac{5}{2}\\
            \frac{1}{2} & \frac{3}{2} & \frac{5}{2} & 1 & -1 & \frac{5}{2} & 1 & 0 & 4\\
        }
    \end{equation}


    \section{Альтенирование по части индексов}

    Применяем уже написанные функции:

    \begin{equation}
        \arr{ccc|ccc|ccc}{
            0 & 0 & 1 & 0 & 0 & \frac{-1}{2} & -1 & \frac{1}{2} & 0\\
            0 & \frac{-3}{2} & \frac{-5}{2} & \frac{3}{2} & 0 & -3 & \frac{5}{2} & 3 & 0\\
            0 & \frac{1}{2} & \frac{1}{2} & \frac{-1}{2} & 0 & \frac{3}{2} & \frac{-1}{2} & \frac{-3}{2} & 0\\
        }
    \end{equation}


    \section{Послесловие}

    Кажется, быстрее было сделать всё ручками… Особенно — учитывая возню с тем, что естественный способ нумерации размерностей в программировании отличается от индексации многомерных матриц, и с этим тоже много возни… 
    
    Но это для слабаков

\end{document}