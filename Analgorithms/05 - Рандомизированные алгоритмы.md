# Рандомизированные алгоритмы

Время работы зависит не только от самого входа, но и от рандома.

Мы в качестве $T^*(n)$ берём среднее арифметичекое по всем возможным входам с весами в виде вероятности.

То есть - информация, которая позволит оценить, сколько мы ожмдаем прождать, запустив на некоторых данных .
$$
T^*(n) = \sum_{perm} {T(perm)\times probablity(perm)}
$$


## Quick sort (алгоритм Хоара)

 Идея: на каждом шагу берём некий элемент, близкий к медианному, затем все элементы, которые больше него, отправляем в одну часть, остальные - справо.

Докажем по индукции, что $T^*(n) = n \log n$:

$\ldots$





## k-порядковая статистика

***k-я порядковая статистика*** - k-й элемент, если отсортировать массив.

Будем использовать процедуру рассечения массива элементов из алгоритма сортировки [QuickSort](https://neerc.ifmo.ru/wiki/index.php?title=Быстрая_сортировка). Пусть нам надо найти *k*-ую порядковую статистику, а после рассечения опорный элемент встал на позицию *m*

. Возможно три случая:

-  **k = m**. Порядковая статистика найдена.
-  **k < m**. Рекурсивно ищем *k*-ую статистику в первой части массива.

- **k > m**. Рекурсивно ищем $(k−m−1)$-ую статистику во второй части массива.

### Код

*partition* - разделяет подмассив [l, r) шковорнем и возвращает его, шкворня, индекс.

```c++
int findOrderStatistic(int[] array, int k) {
  int left = 0, right = array.length;
  while (true) {
    int mid = partition(array, left, right);

    if (mid == k) {
      return array[mid];
    }
    else if (k < mid) {
      right = mid;
    }
    else {
      left = mid + 1;
    }
  }
}
```

## Алгоритм Блюма, Флойда, Пратта, Ривеста и Тарьяна

> Бывает такое, что лучший известный алгоритм для некоторой задачи работает за лучшее вермя, чем лучший из известных детерминированных. Это тот случай...

Алгоритм пытается за $O(n)$ найти наилучший шкворень (разделяющий элемент).

- Делим на блоки по 5 элементов
- Сортируем каждое по возрастанию
- Берём медиану в каждом блоке
- Найдём медианный элемент среди этих медианных элементов...
- Как? Конечно же, так же - рекурсивно!

Утверждается, что мы получим хороший x.



Найдём время работы:
$$
T(n) \leqslant n + T\left(\frac{n}{5}\right) + T\left( \frac{7n}{10} \right)
$$
А это линейное время. 

Тут константа похуже, чем в рандомизированом... Но зато никакого рандома! Можно ночью спать спокойно.



Почему блоки по 5? Это минимальное нечётное число, которое подходит. Подробнее - в ДЗ.

## Можно ли сортировать быстрее, чем за $n \log n$

Обычно доказательство такого очень сложная. (Сложно доказать, что чего-то не может существовать).

Но тут не очень сложно.

Докажем, что нужно сделать как минимум $n \log n$ сравнений.

В зависимости от сравнения можно менять слеующие действия.

Построим дерево таким образом.

Разных данных есть $n!$ штук, и их все нужно соритровать.

Тогда высота дерева $\approx log(n!) = \sum_{i = 1}^{n} \log i \geq \frac{n}{2} \log \frac{n}{2} = \Omega (n \log n)$.

Но это работает только если мы умеем только сравнивать.

Но, например, с числами можно делать более полезные вещи, например, реализовав bucket sort.

>  *==HINT==*: Можно доказывать невозможность решения задачи за некоторое время, сказав, что тогда можно было бы отсортировать быстрее, чем за $n \log n$

