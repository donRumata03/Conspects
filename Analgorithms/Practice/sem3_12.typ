#import "../algo.typ": *

 
#show: project.with(
  title: 
  "ДЗ 12 
(параллельные алгоритмы)"
)

#counter(heading).update(4)

= Перестановка блоков

Посчитаем индекс, куда нужно переставить каждый элемент.


$
"pos" = "pos_in_block" + "start_pos_of_block_in_res"(p["block_index"])
$

$"start_pos_of_block_in_res"$ считаем, выписав длины блоков в массив на позиции $p[b]$ и посчитав перфиксные суммы.

#counter(heading).update(7)

= Локальная дедупликация

От каждого неперерывного отрезка из одинаковых символов: после всех допустимых операций в любом порядке останется либо 0, либо 1 символ — в зависимости от чётности длины отрезка.

Нужно посчитать индексы элементов в ответе. Утверждается, что это можно получить из префиксной суммы ассоциативной функции отрезка: ```rust struct SegmentInfo {
  left_symbol: char,
  left_symbol_count: usize,
  
  right_symbol: char,
  right_symbol_count: usize,

  deduplicated_center_size: usize
}
```

(Классическая идея из дерева отрезков).

Придётся применить хитрость: хранить первый ненулевой отрезок слева и справа в каждом элементе массива.

Тогда количество элементов получается из $"reduce"$ этой функции по всему массиву, а затем будем параллельно заполнять массив: если в этом отрезке число нечётное, и это первый символ такого типа в отрезке, то положим его в итоговый массив по индексу префиксной суммы этой функции в этом элементе.

= Порядковая статистика

#statement[
Есть массив a[0..n − 1], найти k-ю порядковую статистику (за O(n))
]

Применим алгоритм пяти мужиков.

Напомним: делим массив на блоки по 5, находим в каждом медиану (за $O(1)$),
потом вызываемся рекунсивно от $n / 5$ элементов (поиск медианы из медиан),
фильтруем те элементы, которые либо больше медианы медиан, либо меньше (в зависимости). Размер уменьшится хотя бы в $1 - 3/10$ раза.

$
T(n) <= T(n/5) + T(3 n / 10) + C n => T(n) = O(n)
$

Более того, нка каждом из $log n$ шагов $T_∞ = O(log n)$ операций, то есть итоговый $"span"  = log^2 n$
